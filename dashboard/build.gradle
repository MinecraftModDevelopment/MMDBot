import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

import java.time.OffsetDateTime
import java.time.ZoneOffset
import java.time.format.DateTimeFormatter

plugins {
    id 'application'
    id 'java-library'
    // id 'maven'
    id 'eclipse'
    id 'idea'
    alias(libs.plugins.shadow)
    alias(libs.plugins.licenser)
    id 'org.openjfx.javafxplugin' version '0.0.12'
    alias(libs.plugins.lombok)
    alias(libs.plugins.launch4j)
}

sourceSets {
    common {}
    client {}
    server {}
}

configurations {
    global
    commonImplementation.extendsFrom(global)
    clientImplementation.extendsFrom(global)
    serverImplementation.extendsFrom(global)

    globalCompile
    commonCompileOnly.extendsFrom(globalCompile)
    commonCompileOnly.extendsFrom(globalCompile)
    commonCompileOnly.extendsFrom(globalCompile)

    clientImplementation.extendsFrom(commonImplementation)
    serverImplementation.extendsFrom(commonImplementation)

    clientOnly
    clientImplementation.extendsFrom(clientOnly)
}

group = "com.mcmoddev"
archivesBaseName = "MMDBot-Dashboard"

final var actualDateTime = OffsetDateTime.now(ZoneOffset.UTC).withNano(0)
final var currentDateTime = DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(actualDateTime)

java.toolchain.languageVersion = JavaLanguageVersion.of(17)

application {
    mainClass.set('com.mcmoddev.mmdbot.dashboard.client.Startup')
}

repositories {
    mavenCentral()
    maven {
        url "https://clojars.org/repo/"
    }
    maven { url 'https://jitpack.io' }
}

javafx {
    version = "17"
    modules = ['javafx.controls', 'javafx.fxml', 'javafx.swing', 'javafx.graphics', 'javafx.web']
    configuration = "global"
}

license {
    ignoreFailures = true // Temporarily downgrade license header violations to warnings, because in-flux development
    header = rootProject.file('LicenseHeader.md')
    include '**/*.java'
    include '**/*.kt'
    exclude '**/package-info.java'
    exclude '**/module-info.java'
    newLine = false
    properties {
        year = OffsetDateTime.now(ZoneOffset.UTC).withNano(0).getYear()
    }
}

dependencies {
    global libs.guava
    global libs.slf4japi
    global libs.fastutil
    global libs.kryonet
    global libs.kryo

    globalCompile libs.lombok

    serverImplementation sourceSets.common.output
    clientImplementation sourceSets.common.output

    clientOnly libs.logback

    api sourceSets.server.output
    api sourceSets.common.output
}

tasks.create('clientJar', ShadowJar) {
    from sourceSets.common.output
    from sourceSets.client.output
    configurations = [project.configurations.global, project.configurations.clientOnly]

    manifest {
        attributes(
                'Maven-Artifact': "${group}:${archivesBaseName}:${dashboard_version}",
                'Timestamp': currentDateTime,
                'Specification-Title': archivesBaseName,
                'Specification-Vendor': 'Minecraft Mod Development',
                'Specification-Version': '1',
                'Implementation-Title': archivesBaseName,
                'Implementation-Version': "${dashboard_version}",
                'Implementation-Vendor': 'Minecraft Mod Development',
                'Implementation-Timestamp': currentDateTime,
                'Built-On-Java': "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
                'Built-On': "${project.libs.versions.jda.get()}-${project.libs.versions.chewtils.get()}",
                'Main-Class': application.getMainClassName()
        )
    }

    description = "Creates a JAR which contains the Dashboard Client and its dependencies."
    group = "build"
}

tasks.replace("build", ShadowJar).configure {
    finalizedBy(tasks.getByName("clientJar"))
}

// Relocates all of the tasks from build
tasks.stream().filter({it.group == "build" && it.name != "clientJar"}).forEach({it.group = "other"})

tasks.named("jar", Jar).configure {
    from sourceSets.common.output
    classifier('common-no-deps')
}

tasks.named('shadowJar', ShadowJar).configure {
    from sourceSets.common.output
    classifier('common')
    configurations = [project.configurations.global]
}

launch4j {
    mainClassName = application.getMainClassName()
    icon = "${projectDir}/src/client/resources/icon.ico"
    jarTask = tasks.getByName("clientJar")
    outfile = "${archivesBaseName}-${dashboard_version}.exe"
    copyright = "Minecraft Mod Development"
    copyConfigurable = []
    bundledJrePath = "%JAVA_HOME%"
}
tasks.create("copyExe", Copy) {
    from layout.buildDirectory.dir("launch4j/${archivesBaseName}-${dashboard_version}.exe")
    into layout.buildDirectory.dir("libs/exe")
    group = "build"
    description = "Copies the EXE from the launch4j output folder into the libs one."
}
tasks.named("createExe").configure {
    group = "build"
    finalizedBy(tasks.getByName("copyExe"))
}
